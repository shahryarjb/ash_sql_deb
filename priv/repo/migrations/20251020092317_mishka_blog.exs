defmodule AshSqlDeb.Repo.Migrations.MishkaBlog do
  @moduledoc """
  Updates resources based on their most recent snapshots.

  This file was autogenerated with `mix ash_postgres.generate_migrations`
  """

  use Ecto.Migration

  def up do
    create table(:sites, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :name, :text, null: false
      add :host, :text, null: false
      add :priority, :bigint, default: 0
      add :active, :boolean, default: true
      add :mode, :text, default: "hybrid"
      add :frontend_domain, :text
      add :allowed_origins, {:array, :text}, default: []
      add :master, :boolean, default: false

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :archived_at, :utc_datetime_usec
    end

    create unique_index(:sites, [:host],
             where: "((archived_at IS NULL))",
             name: "sites_unique_host_index"
           )

    create unique_index(:sites, [:name],
             where: "((archived_at IS NULL))",
             name: "sites_unique_name_index"
           )

    create table(:auto_postings, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :name, :text, null: false
      add :plugin, :text, null: false
      add :description, :text
      add :is_active, :boolean, default: false
      add :config, :map, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :archived_at, :utc_datetime_usec

      add :site_id,
          references(:sites,
            column: :id,
            name: "auto_postings_site_id_fkey",
            type: :uuid,
            prefix: "public"
          ),
          null: false
    end

    create index(:auto_postings, [:site_id, :is_active], where: "(archived_at IS NULL)")

    create index(:auto_postings, [:site_id, :plugin],
             unique: true,
             where: "(archived_at IS NULL)"
           )

    create unique_index(:auto_postings, [:plugin, :site_id],
             where: "((archived_at IS NULL))",
             name: "auto_postings_unique_plugin_per_site_index",
             nulls_distinct: false
           )

    create table(:auto_posting_versions, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("uuid_generate_v7()"), primary_key: true
      add :version_action_type, :text, null: false
      add :version_action_name, :text, null: false
      add :version_action_inputs, :map, null: false
      add :site_id, :uuid, null: false

      add :version_source_id,
          references(:auto_postings,
            column: :id,
            name: "auto_posting_versions_version_source_id_fkey",
            type: :uuid,
            prefix: "public",
            on_delete: :delete_all
          ),
          null: false

      add :changes, :map

      add :version_inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :version_updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create constraint(:auto_postings, :name_length,
             check: """
               (length(name) >= 1 AND length(name) <= 255) OR NOT ((archived_at IS NULL))
             """
           )

    create constraint(:auto_postings, :plugin_length,
             check: """
               (length(plugin) >= 1 AND length(plugin) <= 255) OR NOT ((archived_at IS NULL))
             """
           )

    execute("""
    CREATE OR REPLACE FUNCTION prevent_archived_auto_posting_updates()
    RETURNS TRIGGER AS $$
    BEGIN
      -- Allow unarchiving (archived_at: NOT NULL -> NULL)
      IF OLD.archived_at IS NOT NULL AND NEW.archived_at IS NULL THEN
        RETURN NEW;
      END IF;

      -- Prevent other updates on archived records
      IF OLD.archived_at IS NOT NULL THEN
        RAISE EXCEPTION 'Cannot update archived auto-posting configuration'
          USING ERRCODE = 'check_violation';
      END IF;

      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;
    """)

    execute("""
    CREATE TRIGGER prevent_archived_auto_posting_updates_trigger
      BEFORE UPDATE ON auto_postings
      FOR EACH ROW
      EXECUTE FUNCTION prevent_archived_auto_posting_updates();
    """)

    create constraint(:sites, :name_length_check,
             check: """
               (length(name) >= 3 AND length(name) <= 70) OR NOT ((archived_at IS NULL))
             """
           )

    create constraint(:sites, :host_length_check,
             check: """
               (length(host) >= 3 AND length(host) <= 200) OR NOT ((archived_at IS NULL))
             """
           )

    create constraint(:sites, :priority_range_check,
             check: """
               (priority >= 0 AND priority <= 100) OR NOT ((archived_at IS NULL))
             """
           )

    create constraint(:sites, :mode_values_check,
             check: """
               (mode IN ('api_only', 'phoenix_only', 'hybrid')) OR NOT ((archived_at IS NULL))
             """
           )

    create constraint(:sites, :no_empty_strings,
             check: """
               (name != '' AND host != '') OR NOT ((archived_at IS NULL))
             """
           )
  end

  def down do
    drop_if_exists constraint(:sites, :no_empty_strings)

    drop_if_exists constraint(:sites, :mode_values_check)

    drop_if_exists constraint(:sites, :priority_range_check)

    drop_if_exists constraint(:sites, :host_length_check)

    drop_if_exists constraint(:sites, :name_length_check)

    execute("""
    DROP TRIGGER IF EXISTS prevent_archived_auto_posting_updates_trigger ON auto_postings;
    """)

    execute("""
    DROP FUNCTION IF EXISTS prevent_archived_auto_posting_updates();
    """)

    drop_if_exists constraint(:auto_postings, :plugin_length)

    drop_if_exists constraint(:auto_postings, :name_length)

    drop constraint(:auto_posting_versions, "auto_posting_versions_version_source_id_fkey")

    drop table(:auto_posting_versions)

    drop_if_exists unique_index(:auto_postings, [:plugin, :site_id],
                     name: "auto_postings_unique_plugin_per_site_index"
                   )

    drop constraint(:auto_postings, "auto_postings_site_id_fkey")

    drop_if_exists index(:auto_postings, [:site_id, :plugin])

    drop_if_exists index(:auto_postings, [:site_id, :is_active])

    drop table(:auto_postings)

    drop_if_exists unique_index(:sites, [:name], name: "sites_unique_name_index")

    drop_if_exists unique_index(:sites, [:host], name: "sites_unique_host_index")

    drop table(:sites)
  end
end
